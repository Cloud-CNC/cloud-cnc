---
to: src/controllers/<%- h.changeCase.param(h.inflection.singularize(name)) %>.spec.ts
---
/**
 * @fileoverview <%- h.changeCase.sentence(h.inflection.singularize(name)) %> controller unit tests
 */

//Imports
import {<%- h.changeCase.camel(h.inflection.singularize(name)) %>A, <%- h.changeCase.camel(h.inflection.singularize(name)) %>B} from '!/fixtures/<%- h.changeCase.param(h.inflection.singularize(name)) %>';
import {<%- h.changeCase.pascal(h.inflection.singularize(name), false) %>} from '@/models/<%- h.changeCase.param(h.inflection.singularize(name)) %>';
import {createSandbox} from 'sinon';
import {
<% for (const [operation, separator] of h.list(entity.operations, ',')) { -%>
  <%- operation.name %><%- separator %>
<% } -%>
} from './<%- h.changeCase.param(h.inflection.singularize(name)) %>';
import hooks from '@/lib/hooks';
import test from 'ava';

//Sinon sandbox
const sandbox = createSandbox();
test.afterEach.always('Restore sandbox', () =>
{
  sandbox.restore();
});

//Tests
<% for (const [operation, separator] of h.list(entity.operations, '\n\n')) { -%>
test.serial('<%- operation.description %>', async ctx =>
{
<% switch (operation.type) { case 'all': -%>
<% if (operation.responseFields.length > 0) { -%>
  //Test data
  const output = [
    {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
      <%- field.name %>: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.<%- field.name %><%- separator %>
<% } -%>
    },
    {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
      <%- field.name %>: <%- h.changeCase.camel(h.inflection.singularize(name)) %>B.<%- field.name %><%- separator %>
<% } -%>
    }
  ];

  //Stub the callHook method
  const callHook = sandbox.stub(hooks, 'callHook').resolves();

  //Stub the toObject method
  const toObject = sandbox.stub()
    .onCall(0)
    .returns(output[0])
    .onCall(1)
    .returns(output[1]);

<% } -%>
  //Stub the find method
  const find = sandbox.stub(<%- h.changeCase.pascal(h.inflection.singularize(name), false) %>, 'find')
    .resolves(<% if (operation.responseFields.length > 0) { %>Array(2).fill({
      toObject
    })<% } %>);

  //Get all <%- h.changeCase.no(h.inflection.pluralize(name)) %>
  <% if (operation.responseFields.length > 0) { %>const <%- h.changeCase.camel(h.inflection.pluralize(name)) %> = <% } %>await <%- operation.name %>();

  //Ensure the result is expected
<% if (operation.responseFields.length > 0) { -%>
  ctx.deepEqual(<%- h.changeCase.camel(h.inflection.pluralize(name)) %>, output);
<% } -%>
  ctx.assert(find.calledOnceWithExactly({}<% if (operation.responseFields.length > 0) { %>, {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
    <%- field.name %>: 1<%- separator %>
<% } -%>
  }<% } %>));
<% if (operation.responseFields.length > 0) { -%>
  ctx.assert(toObject.alwaysCalledWithExactly());
  ctx.assert(toObject.calledTwice);
<% } -%>
  ctx.assert(callHook.getCall(0).calledWithExactly('<%- operation.name %>:pre'));
  ctx.assert(callHook.getCall(1).calledWithExactly('<%- operation.name %>:post', Array(2).fill({
    toObject
  })));
  ctx.assert(callHook.calledTwice);
<% break; case 'create': -%>
  //Test data
<% if (operation.requestFields.length > 0) { -%>
  const input = {
<% for (const [field, separator] of h.list(operation.requestFields, ',')) { -%>
    <%- field.name %>: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.<%- field.name %><%- separator %>
<% } -%>
  };

<% } if (operation.responseFields.length > 0) { -%>
  const output = {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
    <%- field.name %>: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.<%- field.name %><%- separator %>
<% } -%>
  };

<% } -%>
  //Stub the callHook method
  const callHook = sandbox.stub(hooks, 'callHook').resolves();

  //Stub the save method
  const save = sandbox.stub().resolves();

  //Stub the create method
  const create = sandbox.stub(<%- h.changeCase.pascal(h.inflection.singularize(name), false) %>, 'create')
    .resolves({
      id: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id,
      save
    });

  //Create the <%- h.changeCase.no(h.inflection.singularize(name)) %>
  <% if (operation.responseFields.length > 0) { %>const <%- h.changeCase.camel(h.inflection.singularize(name)) %> = <% } %>await <%- operation.name %>(<% if (operation.requestFields.length > 0) { %>input<% } %>);

  //Ensure the result is expected
<% if (operation.responseFields.length > 0) { -%>
  ctx.deepEqual(<%- h.changeCase.camel(h.inflection.singularize(name)) %><% if (operation.responseFields.length > 0) { %>, output<% } %>);
<% } -%>
  //@ts-ignore Sinon types are outdated
  ctx.assert(create.calledOnceWithExactly(<% if (operation.requestFields.length > 0) { %>input<% } %>));
  ctx.assert(save.calledOnceWithExactly());
  ctx.assert(callHook.getCall(0).calledWithExactly('<%- operation.name %>:pre'<% if (operation.requestFields.length > 0) { %>, input<% } %>));
  ctx.assert(callHook.getCall(1).calledWithExactly('<%- operation.name %>:post', {
    id: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id,
    save
  } as any));
  ctx.assert(callHook.calledTwice);
<% break; case 'get': -%>
<% if (operation.responseFields.length > 0) { -%>
  //Test data
  const output = {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
    <%- field.name %>: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.<%- field.name %><%- separator %>
<% } -%>
  };
  
<% } -%>
  //Stub the callHook method
  const callHook = sandbox.stub(hooks, 'callHook').resolves();

<% if (operation.responseFields.length > 0) { -%>
  //Stub the toObject method
  const toObject = sandbox.stub().returns(output);

<% } -%>
  //Stub the findById method
  const findById = sandbox.stub(<%- h.changeCase.pascal(h.inflection.singularize(name), false) %>, 'findById')
    .resolves({
      id: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id<% if (operation.responseFields.length > 0) { %>,
      toObject<% } %>
    });

  //Get the <%- h.changeCase.no(h.inflection.singularize(name)) %>
  <% if (operation.responseFields.length > 0) { %>const <%- h.changeCase.camel(h.inflection.singularize(name)) %> = <% } %>await <%- operation.name %>(<%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id);

  //Ensure the result is expected
<% if (operation.responseFields.length > 0) { -%>
  ctx.deepEqual(<%- h.changeCase.camel(h.inflection.singularize(name)) %>, output);
<% } -%>
  ctx.assert(findById.calledOnceWithExactly(<%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id<% if (operation.responseFields.length > 0) { %>, {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
    <%- field.name %>: 1<%- separator %>
<% } -%>
  }<% } %>));
<% if (operation.responseFields.length > 0) { -%>
  ctx.assert(toObject.alwaysCalledWithExactly());
  ctx.assert(toObject.calledOnce);
<% } -%>
  ctx.assert(callHook.getCall(0).calledWithExactly('<%- operation.name %>:pre', <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id));
  ctx.assert(callHook.getCall(1).calledWithExactly('<%- operation.name %>:post', {
    id: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id<% if (operation.responseFields.length > 0) { %>,
    toObject<% } %>
  } as any));
  ctx.assert(callHook.calledTwice);
<% break; case 'update': -%>
  //Test data
<% if (operation.requestFields.length > 0) { -%>
  const input = {
<% for (const [field, separator] of h.list(operation.requestFields, ',')) { -%>
    <%- field.name %>: <%- h.changeCase.camel(h.inflection.singularize(name)) %>B.<%- field.name %><%- separator %>
<% } -%>
  };

<% } if (operation.responseFields.length > 0) { -%>
  const output = {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
    <%- field.name %>: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.<%- field.name %><%- separator %>
<% } -%>
  };

<% } -%>
  //Stub the callHook method
  const callHook = sandbox.stub(hooks, 'callHook').resolves();

<% if (operation.responseFields.length > 0) { -%>
  //Stub the toObject method
  const toObject = sandbox.stub().returns(output);

<% } -%>
  //Stub the findByIdAndUpdate method
  const findByIdAndUpdate = sandbox.stub(<%- h.changeCase.pascal(h.inflection.singularize(name), false) %>, 'findByIdAndUpdate')
    .resolves({
      id: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id<% if (operation.responseFields.length > 0) { %>,
      toObject<% } %>
    });

  //Update the <%- h.changeCase.no(h.inflection.singularize(name)) %>
  <% if (operation.responseFields.length > 0) { %>const <%- h.changeCase.camel(h.inflection.singularize(name)) %> = <% } %>await <%- operation.name %>(<%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id<% if (operation.requestFields.length > 0) { %>, input<% } %>);

  //Ensure the result is expected
<% if (operation.responseFields.length > 0) { -%>
  ctx.deepEqual(<%- h.changeCase.camel(h.inflection.singularize(name)) %>, output);
<% } -%>
  ctx.assert(findByIdAndUpdate.calledOnceWithExactly(<%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id, {
    $set: input
  }<% if (operation.responseFields.length > 0) { %>, {
    new: true,
    projection: {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
      <%- field.name %>: 1<%- separator %>
<% } -%>
    }
  }<% } %>));
<% if (operation.responseFields.length > 0) { -%>
  ctx.assert(toObject.alwaysCalledWithExactly());
  ctx.assert(toObject.calledOnce);
<% } -%>
  ctx.assert(callHook.getCall(0).calledWithExactly('<%- operation.name %>:pre'<% if (operation.requestFields.length > 0) { %>, input<% } %>));
  ctx.assert(callHook.getCall(1).calledWithExactly('<%- operation.name %>:post', {
    id: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id<% if (operation.responseFields.length > 0) { %>,
    toObject<% } %>
  } as any));
  ctx.assert(callHook.calledTwice);
<% break; case 'delete': -%>
<% if (operation.responseFields.length > 0) { -%>
  //Test data
  const output = {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
    <%- field.name %>: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.<%- field.name %><%- separator %>
<% } -%>
  };

<% } -%>
  //Stub the callHook method
  const callHook = sandbox.stub(hooks, 'callHook').resolves();

<% if (operation.responseFields.length > 0) { -%>
  //Stub the toObject method
  const toObject = sandbox.stub().returns(output);

<% } -%>
  //Stub the findByIdAndDelete method
  const findByIdAndDelete = sandbox.stub(<%- h.changeCase.pascal(h.inflection.singularize(name), false) %>, 'findByIdAndDelete')
    .resolves({
      id: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id<% if (operation.responseFields.length > 0) { %>,
      toObject<% } %>
    });
  
  //Delete the <%- h.changeCase.no(h.inflection.singularize(name)) %>
  <% if (operation.responseFields.length > 0) { %>const <%- h.changeCase.camel(h.inflection.singularize(name)) %> = <% } %>await <%- operation.name %>(<%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id);

  //Ensure the result is expected
<% if (operation.responseFields.length > 0) { -%>
  ctx.deepEqual(<%- h.changeCase.camel(h.inflection.singularize(name)) %>, output);
<% } -%>
  ctx.assert(findByIdAndDelete.calledOnceWithExactly(<%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id<% if (operation.responseFields.length > 0) { %>, {
    projection: {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
      <%- field.name %>: 1<%- separator %>
<% } -%>
    }
  }<% } %>));
<% if (operation.responseFields.length > 0) { -%>
  ctx.assert(toObject.alwaysCalledWithExactly());
  ctx.assert(toObject.calledOnce);
<% } -%>
  ctx.assert(callHook.getCall(0).calledWithExactly('<%- operation.name %>:pre', <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id));
  ctx.assert(callHook.getCall(1).calledWithExactly('<%- operation.name %>:post', {
    id: <%- h.changeCase.camel(h.inflection.singularize(name)) %>A.id<% if (operation.responseFields.length > 0) { %>,
    toObject<% } %>
  } as any));
  ctx.assert(callHook.calledTwice);
<% break; default: -%>
  //TODO: implement test
  <%- operation.name %>();
<% break; } -%>
});<%- separator -%>
<% } %>