---
to: src/controllers/<%- h.changeCase.param(h.inflection.singularize(name)) %>.ts
---
/**
 * @fileoverview <%- h.changeCase.sentence(h.inflection.singularize(name)) %> model
 */

//Imports
import log from '@/lib/log';
import {<%- h.changeCase.pascal(h.inflection.singularize(name), false) %>, I<%- h.changeCase.pascal(h.inflection.singularize(name), false) %>} from '@/models/<%- h.changeCase.param(h.inflection.singularize(name)) %>';

<% for (const operation of entity.operations) { -%>
/**
<%- h.multiline(operation.description, 1) %>
 */
<% switch (operation.type) { case 'all': -%>
const <%- operation.name %> = async (<% if (operation.ownable) { %>owner: string<% } %>) =>
{
  //Get all <%- h.changeCase.no(h.inflection.pluralize(name)) %>
  const <%- h.changeCase.camel(h.inflection.pluralize(name)) %> = await <%- h.changeCase.pascal(h.inflection.singularize(name), false) %>.find({<% if (operation.ownable) { %>owner<% } %>}, {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
    <%- field.name %>: 1<%- separator %>
<% } -%>
  });

  //Log
  log.info('Got all <%- h.changeCase.no(h.inflection.pluralize(name)) %>.');

  return <%- h.changeCase.camel(h.inflection.pluralize(name)) %>;
};
<% break; case 'create': -%>
const <%- operation.name %> = async (create: I<%- h.changeCase.pascal(h.inflection.singularize(name), false) %>) =>
{
  //Create the <%- h.changeCase.no(h.inflection.singularize(name)) %>
  const <%- h.changeCase.camel(h.inflection.singularize(name)) %> = await <%- h.changeCase.pascal(h.inflection.singularize(name), false) %>.create(create);

  //Save the <%- h.changeCase.no(h.inflection.singularize(name)) %>
  await <%- h.changeCase.camel(h.inflection.singularize(name)) %>.save();

  //Log
  log.info(`Created <%- h.changeCase.no(h.inflection.singularize(name)) %> ${<%- h.changeCase.camel(h.inflection.singularize(name)) %>.id}.`);

  return {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
    <%- field.name %>: <%- h.changeCase.camel(h.inflection.singularize(name)) %>.<%- field.name %><%- separator %>
<% } -%>
  };
};
<% break; case 'get': -%>
const <%- operation.name %> = async (id: string) =>
{
  //Get the <%- h.changeCase.no(h.inflection.singularize(name)) %>
  const <%- h.changeCase.camel(h.inflection.singularize(name)) %> = await <%- h.changeCase.pascal(h.inflection.singularize(name), false) %>.findById(id, {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
    <%- field.name %>: 1<%- separator %>
<% } -%>
  });

  //Ensure the <%- h.changeCase.no(h.inflection.singularize(name)) %> exists
  if (<%- h.changeCase.camel(h.inflection.singularize(name)) %> == null)
  {
    throw new Error(`Invalid <%- h.changeCase.no(h.inflection.singularize(name)) %> with ID ${id}!`);
  }

  //Log
  log.info(`Got <%- h.changeCase.no(h.inflection.singularize(name)) %> ${<%- h.changeCase.camel(h.inflection.singularize(name)) %>.id}.`);

  return <%- h.changeCase.camel(h.inflection.singularize(name)) %>;
};
<% break; case 'update': -%>
const <%- operation.name %> = async (id: string, update: I<%- h.changeCase.pascal(h.inflection.singularize(name), false) %>) =>
{
  //Get the <%- h.changeCase.no(h.inflection.singularize(name)) %>
  const <%- h.changeCase.camel(h.inflection.singularize(name)) %> = await <%- h.changeCase.pascal(h.inflection.singularize(name), false) %>.findById(id, {
<% for (const [field, separator] of h.list(operation.responseFields, ',')) { -%>
    <%- field.name %>: 1<%- separator %>
<% } -%>
  });

  //Ensure the <%- h.changeCase.no(h.inflection.singularize(name)) %> exists
  if (<%- h.changeCase.camel(h.inflection.singularize(name)) %> == null)
  {
    throw new Error(`Invalid <%- h.changeCase.no(h.inflection.singularize(name)) %> with ID ${id}!`);
  }

  //Update the <%- h.changeCase.no(h.inflection.singularize(name)) %>
  await <%- h.changeCase.camel(h.inflection.singularize(name)) %>.update(update);

  //Log
  log.info(`Updated <%- h.changeCase.no(h.inflection.singularize(name)) %> ${<%- h.changeCase.camel(h.inflection.singularize(name)) %>.id}.`);

  return <%- h.changeCase.camel(h.inflection.singularize(name)) %>;
};
<% break; case 'delete': -%>
const <%- operation.name %> = async (id: string) =>
{
  //Delete the <%- h.changeCase.no(h.inflection.singularize(name)) %>
  const <%- h.changeCase.camel(h.inflection.singularize(name)) %> = await <%- h.changeCase.pascal(h.inflection.singularize(name), false) %>.findByIdAndDelete(id);

  //Ensure the <%- h.changeCase.no(h.inflection.singularize(name)) %> exists
  if (<%- h.changeCase.camel(h.inflection.singularize(name)) %> == null)
  {
    throw new Error(`Invalid <%- h.changeCase.no(h.inflection.singularize(name)) %> with ID ${id}!`);
  }

  //Log
  log.info(`Deleted <%- h.changeCase.no(h.inflection.singularize(name)) %> ${<%- h.changeCase.camel(h.inflection.singularize(name)) %>.id}.`);

  return <%- h.changeCase.camel(h.inflection.singularize(name)) %>;
};
<% break; default: -%>
const <%- operation.name %> = () =>
{
  //TODO: implement business logic

  //TODO: log
};
<% break; } -%>

<% } -%>
//Export
export {
<% for (const [operation, separator] of h.list(entity.operations, ',')) { -%>
  <%- operation.name %><%- separator %>
<% } -%>
};